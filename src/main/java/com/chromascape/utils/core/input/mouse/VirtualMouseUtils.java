package com.chromascape.utils.core.input.mouse;

import com.chromascape.base.BaseScript;
import com.chromascape.utils.core.input.remoteinput.Kinput;
import com.chromascape.utils.core.screen.window.ScreenManager;
import com.chromascape.utils.core.state.BotState;
import com.chromascape.utils.core.state.StateManager;
import com.chromascape.utils.core.statistics.StatisticsManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.Random;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import javax.swing.SwingUtilities;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * The orchestrator for human-like virtual mouse behavior.
 *
 * <p>Provides movement, clicks, overshoots, pause-corrections, and overlay visuals without
 * hijacking the physical system cursor. Designed for use with remote input libraries like {@link
 * Kinput}, enabling low-level mouse event simulation.
 *
 * <p><b>Performance Note:</b> This class uses a Producer-Consumer threading model. The physics
 * engine (Producer) runs on the calling thread at ~60Hz, while the Input Dispatcher (Consumer) runs
 * on a background thread. This ensures that slow hardware input calls do not slow down the physics
 * calculation.
 */
public class VirtualMouseUtils {

  /** The current virtual mouse position. */
  private Point currentPosition;

  /** Timestamp of the last overlay repaint to control frame rate. */
  private long lastOverlayUpdate = 0;

  /** Semi-transparent visual overlay to show virtual mouse position. */
  private final MouseOverlay overlay;

  /** Interface for injecting low-level mouse events independently of system mouse. */
  private final Kinput kinput;

  /** Random number generator. */
  private final Random random;

  /** Humanised mouse movement service. */
  private final WindMouse windMouse;

  /** Logger with appender to publish logs to the web UI. */
  private static final Logger logger = LogManager.getLogger(VirtualMouseUtils.class);

  /** The latest point generated by the physics engine, waiting to be consumed by Kinput. */
  private final AtomicReference<Point> pendingInputPoint = new AtomicReference<>();

  /** Flag to indicate if the virtual mouse is currently performing a movement path. */
  private final AtomicBoolean isMoving = new AtomicBoolean(false);

  /**
   * Background thread that consumes points from {@code pendingInputPoint} and sends them to
   * hardware.
   */
  private final Thread inputConsumerThread;

  /**
   * Lock object to ensure Kinput is accessed by only one thread at a time.
   *
   * <p>Required because the underlying WebSocket/Connection in Kinput is not thread-safe and cannot
   * handle simultaneous write operations.
   */
  private final Object kinputLock = new Object();

  /**
   * The orchestrator for all inputs mouse related. provides human like mouse movement, clicking and
   * a little overlay so you can see where it is.
   *
   * @param kinput The operating system dependant utility to send low level mouse inputs. This is
   *     how we can still use the system cursor separately while this mouse is active.
   * @param bounds Rectangle, containing the screen's bounds.
   */
  public VirtualMouseUtils(final Kinput kinput, final Rectangle bounds) {
    this.kinput = kinput;
    overlay = new MouseOverlay();
    overlay.setSize(bounds.width, bounds.height);

    random = new Random();
    windMouse = new WindMouse();

    // Randomize starting position within the client window
    int startX = bounds.x + random.nextInt(bounds.width);
    int startY = bounds.y + random.nextInt(bounds.height);
    currentPosition = new Point(startX, startY);
    // Initialize atomic reference to prevent null pointer in consumer
    pendingInputPoint.set(currentPosition);

    // Place overlay at the same randomized position
    SwingUtilities.invokeLater(() -> overlay.setMousePoint(currentPosition));
    overlay.setLocation(bounds.x, bounds.y); // keep overlay frame aligned with window

    // Start the background Input Consumer thread
    inputConsumerThread = new Thread(this::consumeInputLoop, "VirtualMouse-Input-Consumer");
    inputConsumerThread.setDaemon(true); // Ensure thread dies when JVM shuts down
    inputConsumerThread.start();
  }

  /**
   * The loop for the background thread. Continuously checks for new points and sends them to
   * Kinput.
   */
  private void consumeInputLoop() {
    Point lastSentPoint = null;

    while (true) {
      try {
        if (isMoving.get()) {
          Point target = pendingInputPoint.get();

          // Only send input if the point is new (and not null)
          if (target != null && !target.equals(lastSentPoint)) {
            Point clientPoint = ScreenManager.toClientCoords(target);

            // Prevent collision with clicks or final snaps
            synchronized (kinputLock) {
              kinput.moveMouse(clientPoint.x, clientPoint.y);
            }

            lastSentPoint = target;
          }
        } else {
          // If not moving, sleep longer to save resources
          BaseScript.waitMillis(5);
        }
      } catch (Exception e) {
        // Log error but keep thread alive
        logger.error("Error while consuming inputL {}", e.getMessage());
        logger.error(e.getStackTrace());
      }
    }
  }

  /**
   * Moves the virtual mouse to the given location using the WindMouse algorithm.
   *
   * @param target The destination point.
   * @param speed Speed profile: "slow", "medium", "fast".
   * @throws InterruptedException If movement is externally interrupted.
   */
  public void moveTo(final Point target, final String speed) throws InterruptedException {
    BaseScript.checkInterrupted();
    StateManager.setState(BotState.ACTING);
    StatisticsManager.incrementInputs();

    // Flag start of movement for the Consumer thread
    isMoving.set(true);

    try {
      // Run Physics Loop (Producer) on the current thread.
      // The callback purely updates the AtomicReference and Overlay.
      // It does NOT wait for Kinput.
      windMouse.move(
          currentPosition,
          target,
          speed,
          p -> {
            // Update the shared reference for the Consumer to pick up
            pendingInputPoint.set(p);
            currentPosition = p;

            // Throttle overlay updates to ~60 FPS (16ms)
            long now = System.currentTimeMillis();
            if (now - lastOverlayUpdate >= 16) {
              if (!SwingUtilities.isEventDispatchThread()) {
                SwingUtilities.invokeLater(() -> overlay.setMousePoint(p));
                lastOverlayUpdate = now;
              }
            }
          });
    } finally {
      // Movement finished.
      isMoving.set(false);

      // Force the final position update to ensure exact accuracy.
      currentPosition = target;
      pendingInputPoint.set(target); // Sync consumer for safety

      Point finalClientPoint = ScreenManager.toClientCoords(target);

      // SYNCHRONIZED: Ensure final snap doesn't crash connection
      synchronized (kinputLock) {
        kinput.moveMouse(finalClientPoint.x, finalClientPoint.y);
      }

      SwingUtilities.invokeLater(() -> overlay.setMousePoint(target));
    }
  }

  /** Simulates a left-click at the current virtual mouse location. */
  public void leftClick() {
    performClick(
        (p) -> {
          synchronized (kinputLock) {
            kinput.clickMouse(p.x, p.y, Kinput.MouseButton.LEFT.id);
            // Redundant move ensures OS registers click at correct coords if jitter occurred
            kinput.moveMouse(p.x, p.y);
          }
        });
  }

  /** Simulates a right-click at the current virtual mouse location. */
  public void rightClick() {
    performClick(
        (p) -> {
          synchronized (kinputLock) {
            kinput.clickMouse(p.x, p.y, Kinput.MouseButton.RIGHT.id);
            kinput.moveMouse(p.x, p.y);
          }
        });
  }

  /**
   * Scrolls the mouse wheel at the current virtual cursor location.
   *
   * @param rotation Positive for scroll up, negative for scroll down.
   */
  public void scrollWheel(int rotation) {
    BaseScript.checkInterrupted();
    StateManager.setState(BotState.ACTING);
    StatisticsManager.incrementInputs();
    Point clientPoint = ScreenManager.toClientCoords(currentPosition);
    synchronized (kinputLock) {
      kinput.scrollWheel(clientPoint.x, clientPoint.y, rotation);
    }
  }

  /**
   * Simulates a middle mouse button input.
   *
   * @param eventType The event code (501 for press, 502 for release).
   */
  public void middleClick(int eventType) {
    performClick(
        (p) -> {
          synchronized (kinputLock) {
            kinput.middleInput(p.x, p.y, eventType);
          }
        });
  }

  /**
   * Applies a micro-jitter (1â€“3 pixels) to the virtual cursor, intended to simulate small human
   * hand movements when clicking.
   */
  public void microJitter() {
    if (random.nextBoolean()) {
      currentPosition.translate(random.nextInt(-1, 2), random.nextInt(-1, 4));

      // Update consumer reference so hardware reflects jitter
      pendingInputPoint.set(currentPosition);

      SwingUtilities.invokeLater(() -> overlay.setMousePoint(currentPosition));

      // We can force this update directly as jitter is a single discrete action,
      // not a high-frequency loop.
      Point clientPoint = ScreenManager.toClientCoords(currentPosition);

      synchronized (kinputLock) {
        kinput.moveMouse(clientPoint.x, clientPoint.y);
      }
    }
  }

  /** Helper to perform common action logic (Stats, State, Coordinate Conversion). */
  private void performClick(Consumer<Point> action) {
    BaseScript.checkInterrupted();
    StateManager.setState(BotState.ACTING);
    StatisticsManager.incrementInputs();
    Point clientPoint = ScreenManager.toClientCoords(currentPosition);
    action.accept(clientPoint);
  }

  /**
   * Returns the Mouse overlay object. Intended to be used by the Controller to destroy the overlay.
   *
   * @return The MouseOverlay object.
   */
  public MouseOverlay getMouseOverlay() {
    return overlay;
  }
}
